"use strict";
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable max-classes-per-file */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const isomorphic_fetch_1 = __importDefault(require("isomorphic-fetch"));
function encodeBasicAuth(username, password) {
    const str = `${username}:${password}`;
    const buffer = Buffer.from(str);
    return `Basic ${buffer.toString('base64')}`;
}
class ApiClientError extends Error {
    constructor(status, body, url) {
        body = body || {};
        super(`Request to ${url} failed with HTTP${status}: ${JSON.stringify(body)}`);
        this.name = `HTTP${status}`;
        this.code = body.code;
        this.field = body.field;
        this.body = body;
        this.status = status;
        this.url = url;
        // https://tools.ietf.org/html/rfc7807
        this.type = body.type;
        this.title = body.title;
        this.detail = body.detail;
        this.instance = body.instance;
    }
}
exports.ApiClientError = ApiClientError;
async function headersNoop() {
    return {};
}
function bearerTokenHeaders(accessToken) {
    if (!accessToken)
        return headersNoop;
    const Authorization = `Bearer ${accessToken}`;
    return async () => {
        return { Authorization };
    };
}
exports.bearerTokenHeaders = bearerTokenHeaders;
class ApiClient {
    constructor(baseUrl, getHeaders) {
        this.baseUrl = baseUrl;
        this.getHeaders = getHeaders || headersNoop;
    }
    withAccessToken(value) {
        return new ApiClient(this.baseUrl, bearerTokenHeaders(value));
    }
    withBasicAuth(username, password) {
        const Authorization = encodeBasicAuth(username, password);
        return new ApiClient(this.baseUrl, async () => {
            return { Authorization };
        });
    }
    async invalidate() {
        return null;
    }
    async request(method, path, query, body) {
        const url = new URL(this.baseUrl + path);
        if (query) {
            Object.keys(query || {}).forEach((name) => {
                const val = query[name];
                if (Array.isArray(val)) {
                    val.forEach((v) => {
                        url.searchParams.append(name, v);
                    });
                }
                else {
                    url.searchParams.append(name, val || '');
                }
            });
        }
        const params = {
            method,
            headers: await this.getHeaders(),
        };
        if (body) {
            params.headers['Content-Type'] = 'application/json';
            params.body = JSON.stringify(body);
        }
        const response = await isomorphic_fetch_1.default(url.toString(), params);
        const contentType = response.headers.get('Content-Type');
        if (response.status === 401) {
            await this.invalidate();
        }
        let json;
        if (/^application\/json/.test(contentType || '')) {
            json = await response.json();
        }
        else if (/^application\/problem\+json/.test(contentType || '')) {
            json = await response.json();
        }
        // console.log(url.toString(), response.status, json);
        if (response.status >= 400)
            throw new ApiClientError(response.status, json, url.toString());
        return json;
    }
    async get(path, query) {
        return this.request('GET', path, query);
    }
    async post(path, body, query) {
        return this.request('POST', path, query, body);
    }
    async put(path, body, query) {
        return this.request('PUT', path, query, body);
    }
    async patch(path, body, query) {
        return this.request('PATCH', path, query, body);
    }
    async delete(path, body, query) {
        return this.request('DELETE', path, query, body);
    }
}
exports.default = ApiClient;
